# puppet4-externe-tools-ecosystem-benutzer-funktionen

Wenn Sie das Rezept gelesen haben Mit GnuPG verschlüsseln Sie Geheimnisse in [Puppet4 Arbeiten mit Dateien und Paketen](../puppet4-datein-packete), dann haben Sie bereits ein Beispiel für eine benutzerdefinierte Funktion gesehen (in diesem Beispiel haben wir eine `secret` Funktion erstellt, die sich auf GnuPG ausschloss ). Schauen wir uns die benutzerdefinierten Funktionen in ein wenig mehr Details an und bauen ein Beispiel.
Wie es geht...

Wenn Sie das Rezept gelesen haben. Cron-Aufträge effizient in [Puppet4 Management von Ressourcen und Dateien](../puppet4-ressourcen-datein), können Sie sich daran erinnern, dass wir die Funktion `inline_template` verwendet haben, um eine zufällige Zeit für Cron-Aufträge festzulegen, die auf dem Hostnamen des Knotens ausgeführt werden sollen. In diesem Beispiel nehmen wir diese Idee und verwandeln sie in eine benutzerdefinierte Funktion namens `random_minute`:

1.Erstellen Sie die Datei `modules/cookbook/lib/puppet/parser/functions/random_minute.rb` mit folgendem Inhalt:

```pp
module Puppet::Parser::Functions
  newfunction(:random_minute, :type => :rvalue) do |args|
    lookupvar('hostname').sum % 60
  end
end
```

2.Ändern Sie Ihre `site.pp` Datei wie folgt:

```pp
node 'cookbook' {
  cron { 'randomised cron job':
    command => '/bin/echo Hello, world >>/tmp/hello.txt',
    hour    => '*',
    minute  => random_minute(),
  }
}
```

3.Puppet run:

```s
[root@cookbook ~]# puppet agent -t
Info: Retrieving pluginfacts
Info: Retrieving plugin
Notice: /File[/var/lib/puppet/lib/puppet/parser/functions/random_minute.rb]/ensure: defined content as '{md5}e6ff40165e74677e5837027bb5610744'
Info: Loading facts
Info: Caching catalog for cookbook.example.com
Info: Applying configuration version '1416379652'
Notice: /Stage[main]/Main/Node[cookbook]/Cron[custom fuction example job]/ensure: created
Notice: Finished catalog run in 0.41 seconds
```

4.Überprüfen Sie `crontab` mit folgendem Befehl:

```s
[root@cookbook ~]# crontab -l
# HEADER: This file was autogenerated at Wed Nov 19 01:48:11 -0500 2014 by puppet.
# HEADER: While it can still be managed manually, it is definitely not recommended.
# HEADER: Note particularly that the comments starting with 'Puppet Name' should
# HEADER: not be deleted, as doing so could cause duplicate cron jobs.
# Puppet Name: run-backup
0 15 * * * /usr/local/bin/backup
# Puppet Name: custom fuction example job
15 * * * * /bin/echo Hallo, welt >>/tmp/hallo.txt
```

## Wie es funktioniert

Benutzerdefinierte Funktionen können in jedem Modul, in der `lib/puppet/parser/functions` Unterverzeichnis in einer Datei benannt nach der Funktion (in unserem Beispiel, `random_minute.rb`) leben.

Der Funktionscode geht in ein `module ... end` wie folgt:

```pp
module Puppet::Parser::Functions
  ...
end
```

Wir rufen dann `newfunction` an, um unsere neue Funktion zu deklarieren, den Namen (`:random_minute`) und den Typ der Funktion (`:rvalue`) zu übergeben:
`newfunction(:random_minute, :type => :rvalue) do |args|`

Das `:rvalue` bedeutet, dass diese Funktion einen Wert zurückgibt.

Schließlich ist der Funktionscode selbst wie folgt:
`lookupvar('hostname').sum % 60`

Mit der `lookupvar` Funktion können Sie auf Fakten und Variablen nach Namen zugreifen. In diesem Fall `hostname`, um den Namen des Node zu erhalten, auf dem wir laufen. Wir verwenden die Ruby `sum` methode, um die numerische Summe der Zeichen in dieser Zeichenkette zu erhalten, und führen Sie dann eine Ganzzahl-Teilung modulo 60 aus, um sicherzustellen, dass das Ergebnis im Bereich `0..59` liegt.

## Es gibt mehr

Sie können natürlich viel mehr mit benutzerdefinierten Funktionen machen. In der Tat, alles, was Sie in Ruby tun können, können Sie in einer benutzerdefinierten Funktion zu tun. Sie haben auch Zugriff auf alle Fakten und Variablen, die im Geltungsbereich an der Stelle im Puppenmanifest sind, wo die Funktion aufgerufen wird, indem Sie `lookupvar` aufrufen, wie im Beispiel gezeigt. Sie können auch an Argumenten arbeiten, zum Beispiel eine Allzweck-Hash-Funktion, die zwei Argumente annimmt: die Größe der Hash-Tabelle und optional die Sache zu Hash. Erstellen Sie `modules/cookbook/lib/puppet/parser/functions/hashtable.rb` mit folgendem Inhalt:

```pp
module Puppet::Parser::Functions
  newfunction(:hashtable, :type => :rvalue) do |args|
    if args.length == 2
      hashtable=lookupvar(args[1]).sum
    else
      hashtable=lookupvar('hostname').sum
    end

    if args.length > 0
      size = args[0].to_i
    else
      size = 60
    end
    unless size == 0
      hashtable % size
    else
      0
    end
  end
end
```

Jetzt erstellen wir einen Test für unsere `hashtable` Funktion und ändern `site.pp` wie folgt:

```pp
node cookbook {
  $hours = hashtable(24)
  $minutes = hashtable()
  $days = hashtable(30)
  $days_fqdn = hashtable(30,'fqdn')
  $days_ipaddress = hashtable(30,'ipaddress')
  notify {"\n hours=${hours}\n minutes=${minutes}\n days=${days}\n days_fqdn=${days_fqdn}\n days_ipaddress=${days_ipaddress}\n":}
}
```

Führen Sie nun Puppet aus und beobachten Sie die zurückgegebenen Werte:

```pp
Notice:  hours=15
 minutes=15
 days=15
 days_fqdn=4
 days_ipaddress=2
```

Unsere einfache Definition wuchs schnell, als wir die Möglichkeit hinzugefügt haben, Argumente hinzuzufügen. Wie bei allen Programmen sollte bei der Arbeit mit Argumenten darauf geachtet werden, dass Sie keine Fehlerbedingungen haben. Im vorangehenden Code suchten wir speziell die Situation, in der die Größenvariable 0 war, um eine Division durch Nullfehler(zero error) zu vermeiden.

Um mehr darüber zu erfahren, was Sie mit benutzerdefinierten Funktionen machen können, finden Sie auf der Website der [Puppetlabs](Http://docs.puppetlabs.com/guides/custom_functions.html)
